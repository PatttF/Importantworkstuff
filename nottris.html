<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NotTris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #8b956d;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }

        .main-container {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .gameboy {
            background: linear-gradient(145deg, #c4cfa1, #8b956d);
            border-radius: 20px 20px 60px 20px;
            padding: 20px;
            box-shadow: 
                inset 2px 2px 5px rgba(255,255,255,0.3),
                inset -2px -2px 5px rgba(0,0,0,0.3),
                5px 5px 20px rgba(0,0,0,0.4);
            border: 3px solid #5a6348;
        }

        .screen-container {
            background: #5a6348;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            box-shadow: inset 3px 3px 10px rgba(0,0,0,0.5);
        }

        .screen {
            background: #9bbc0f;
            display: flex;
            gap: 10px;
            padding: 10px;
            border-radius: 5px;
            image-rendering: pixelated;
        }

        .game-area {
            position: relative;
        }

        #gameCanvas {
            display: block;
            background: #8bac0f;
            border: 2px solid #306230;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 100px;
        }

        .panel-box {
            background: #8bac0f;
            border: 2px solid #306230;
            padding: 8px;
            text-align: center;
        }

        .panel-title {
            color: #306230;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .panel-value {
            color: #0f380f;
            font-size: 14px;
            font-weight: bold;
        }

        #nextCanvas {
            display: block;
            background: #9bbc0f;
            margin: 5px auto;
        }

        .title {
            text-align: center;
            color: #0f380f;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 1px 1px 0 #9bbc0f;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
        }

        .dpad {
            width: 100px;
            height: 100px;
            position: relative;
        }

        .dpad-btn {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #2d2d2d;
            border: none;
            cursor: pointer;
            color: #888;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dpad-btn:hover {
            background: #3d3d3d;
        }

        .dpad-btn:active {
            background: #1d1d1d;
        }

        .dpad-up { top: 0; left: 35px; border-radius: 5px 5px 0 0; }
        .dpad-down { bottom: 0; left: 35px; border-radius: 0 0 5px 5px; }
        .dpad-left { left: 5px; top: 35px; border-radius: 5px 0 0 5px; }
        .dpad-right { right: 5px; top: 35px; border-radius: 0 5px 5px 0; }
        .dpad-center { 
            position: absolute;
            left: 35px; 
            top: 30px; 
            width: 30px; 
            height: 40px; 
            background: #2d2d2d; 
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            transform: rotate(-25deg);
        }

        .action-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: #9b1b30;
            border: none;
            cursor: pointer;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 
                inset 2px 2px 5px rgba(255,255,255,0.2),
                inset -2px -2px 5px rgba(0,0,0,0.3),
                2px 2px 5px rgba(0,0,0,0.3);
        }

        .action-btn:hover {
            background: #b22040;
        }

        .action-btn:active {
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
        }

        .menu-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        .menu-btn-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .menu-btn-label {
            font-size: 8px;
            color: #4a5438;
            text-transform: uppercase;
            font-weight: bold;
        }

        .menu-btn {
            width: 50px;
            height: 15px;
            background: #5a6348;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transform: rotate(-25deg);
            font-size: 10px;
            line-height: 15px;
            text-align: center;
        }

        .menu-btn:hover {
            background: #6a7358;
        }

        .menu-btn.playing {
            background: #306230;
        }

        .brand {
            text-align: center;
            margin-top: 15px;
            color: #4a5438;
            font-size: 18px;
            font-weight: bold;
            font-style: italic;
            font-size: 11px;
        }

        .music-btn {
            width: 100%;
            margin-top: 15px;
            padding: 10px;
            background: #5a6348;
            color: #9bbc0f;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 12px;
        }

        .music-btn:hover {
            background: #6a7358;
        }

        .music-btn.playing {
            background: #306230;
            color: #9bbc0f;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 56, 15, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #9bbc0f;
            font-size: 14px;
            text-align: center;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay h2 {
            font-size: 20px;
            margin-bottom: 10px;
        }

        .overlay p {
            margin: 5px 0;
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .instructions {
            font-size: 10px;
            margin-top: 15px;
            color: #8bac0f;
        }
    </style>
</head>
<body>
    <div class="main-container">
    <div class="gameboy">
        <div class="screen-container">
            <div class="title">NOTTRIS</div>
            <div class="screen">
                <div class="game-area">
                    <canvas id="gameCanvas" width="200" height="400"></canvas>
                    <div id="startOverlay" class="overlay">
                        <h2>NOTTRIS</h2>
                        <p>Classic Block Game</p>
                        <p class="blink">PRESS RETURN</p>
                        <div class="instructions">
                            <p>← → : Move</p>
                            <p>↓ : Soft Drop</p>
                            <p>↑/SPACE : Hard Drop</p>
                            <p>Z/X/A/B : Rotate</p>
                        </div>
                    </div>
                    <div id="gameOverOverlay" class="overlay hidden">
                        <h2>GAME OVER</h2>
                        <p>Score: <span id="finalScore">0</span></p>
                        <p class="blink">PRESS RETURN</p>
                    </div>
                    <div id="pauseOverlay" class="overlay hidden">
                        <h2>PAUSED</h2>
                        <p class="blink">PRESS RETURN</p>
                    </div>
                </div>
                <div class="side-panel">
                    <div class="panel-box">
                        <div class="panel-title">Score</div>
                        <div class="panel-value" id="score">0</div>
                    </div>
                    <div class="panel-box">
                        <div class="panel-title">Level</div>
                        <div class="panel-value" id="level">1</div>
                    </div>
                    <div class="panel-box">
                        <div class="panel-title">Lines</div>
                        <div class="panel-value" id="lines">0</div>
                    </div>
                    <div class="panel-box">
                        <div class="panel-title">Next</div>
                        <canvas id="nextCanvas" width="80" height="80"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="menu-buttons">
            <div class="menu-btn-wrapper">
                <button class="menu-btn" id="startBtn" title="Return"></button>
                <span class="menu-btn-label">Return</span>
            </div>
            <div class="menu-btn-wrapper">
                <button class="menu-btn" id="musicBtn" title="Music"></button>
                <span class="menu-btn-label">Music</span>
            </div>
        </div>

        <div class="controls">
            <div class="dpad">
                <button class="dpad-btn dpad-up" id="upBtn">▲</button>
                <button class="dpad-btn dpad-down" id="downBtn">▼</button>
                <button class="dpad-btn dpad-left" id="leftBtn">◄</button>
                <button class="dpad-btn dpad-right" id="rightBtn">►</button>
                <div class="dpad-center"></div>
            </div>
            <div class="action-buttons">
                <button class="action-btn" id="bBtn">B</button>
                <button class="action-btn" id="aBtn">A</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ===== EMBEDDED MIDI DATA (Base64) =====
        const MIDI_BASE64 = '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';

        // ===== SIMPLE MIDI PARSER =====
        function parseMidi(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            
            let pos = 0;
            const notes = [];
            
            // Read header
            const headerChunk = String.fromCharCode(...bytes.slice(0, 4));
            if (headerChunk !== 'MThd') return notes;
            
            pos = 8;
            const format = (bytes[pos] << 8) | bytes[pos + 1];
            const numTracks = (bytes[pos + 2] << 8) | bytes[pos + 3];
            const ticksPerBeat = (bytes[pos + 4] << 8) | bytes[pos + 5];
            pos += 6;
            
            let tempo = 500000; // Default 120 BPM
            
            // Parse tracks
            for (let track = 0; track < numTracks; track++) {
                if (pos >= bytes.length) break;
                
                const trackHeader = String.fromCharCode(...bytes.slice(pos, pos + 4));
                if (trackHeader !== 'MTrk') break;
                
                pos += 4;
                const trackLength = (bytes[pos] << 24) | (bytes[pos + 1] << 16) | (bytes[pos + 2] << 8) | bytes[pos + 3];
                pos += 4;
                
                const trackEnd = pos + trackLength;
                let currentTime = 0;
                let lastStatus = 0;
                const activeNotes = {};
                
                while (pos < trackEnd) {
                    // Read delta time (variable length)
                    let deltaTime = 0;
                    let byte;
                    do {
                        byte = bytes[pos++];
                        deltaTime = (deltaTime << 7) | (byte & 0x7F);
                    } while (byte & 0x80);
                    
                    currentTime += deltaTime;
                    const timeInSeconds = (currentTime / ticksPerBeat) * (tempo / 1000000);
                    
                    // Read event
                    let status = bytes[pos];
                    if (status < 0x80) {
                        status = lastStatus;
                    } else {
                        pos++;
                        lastStatus = status;
                    }
                    
                    const eventType = status & 0xF0;
                    
                    if (eventType === 0x90) { // Note On
                        const note = bytes[pos++];
                        const velocity = bytes[pos++];
                        if (velocity > 0) {
                            activeNotes[note] = { time: timeInSeconds, velocity: velocity / 127 };
                        } else if (activeNotes[note]) {
                            notes.push({
                                note: note,
                                time: activeNotes[note].time,
                                duration: timeInSeconds - activeNotes[note].time,
                                velocity: activeNotes[note].velocity
                            });
                            delete activeNotes[note];
                        }
                    } else if (eventType === 0x80) { // Note Off
                        const note = bytes[pos++];
                        pos++; // velocity
                        if (activeNotes[note]) {
                            notes.push({
                                note: note,
                                time: activeNotes[note].time,
                                duration: timeInSeconds - activeNotes[note].time,
                                velocity: activeNotes[note].velocity
                            });
                            delete activeNotes[note];
                        }
                    } else if (eventType === 0xB0) { // Control Change
                        pos += 2;
                    } else if (eventType === 0xC0) { // Program Change
                        pos++;
                    } else if (eventType === 0xE0) { // Pitch Bend
                        pos += 2;
                    } else if (status === 0xFF) { // Meta event
                        const metaType = bytes[pos++];
                        let metaLength = 0;
                        do {
                            byte = bytes[pos++];
                            metaLength = (metaLength << 7) | (byte & 0x7F);
                        } while (byte & 0x80);
                        
                        if (metaType === 0x51 && metaLength === 3) { // Tempo
                            tempo = (bytes[pos] << 16) | (bytes[pos + 1] << 8) | bytes[pos + 2];
                        }
                        pos += metaLength;
                    } else if (status === 0xF0 || status === 0xF7) { // SysEx
                        let sysexLength = 0;
                        do {
                            byte = bytes[pos++];
                            sysexLength = (sysexLength << 7) | (byte & 0x7F);
                        } while (byte & 0x80);
                        pos += sysexLength;
                    }
                }
            }
            
            return notes;
        }

        // ===== WEB AUDIO SYNTH =====
        let audioCtx = null;
        let musicPlaying = false;
        let scheduledNotes = [];
        let loopTimeout = null;
        let midiNotes = [];

        function midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function createRetroOscillator(freq, startTime, duration, velocity) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'square';
            osc.frequency.value = freq;
            
            const vol = velocity * 0.15;
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(vol, startTime + 0.01);
            gain.gain.setValueAtTime(vol, startTime + duration - 0.02);
            gain.gain.linearRampToValueAtTime(0, startTime + duration);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(startTime);
            osc.stop(startTime + duration);
            
            return { osc, gain };
        }

        function playMidi() {
            if (midiNotes.length === 0) {
                midiNotes = parseMidi(MIDI_BASE64);
            }
            
            initAudio();
            stopMusic();
            
            const startTime = audioCtx.currentTime + 0.1;
            let maxEndTime = 0;
            
            midiNotes.forEach(note => {
                const freq = midiToFreq(note.note);
                const noteStart = startTime + note.time;
                const noteDuration = Math.max(note.duration, 0.05);
                const endTime = noteStart + noteDuration;
                
                if (endTime > maxEndTime) maxEndTime = endTime;
                
                const scheduled = createRetroOscillator(freq, noteStart, noteDuration, note.velocity);
                scheduledNotes.push(scheduled);
            });
            
            musicPlaying = true;
            updateMusicButton();
            
            // Loop the music
            const duration = maxEndTime - startTime;
            loopTimeout = setTimeout(() => {
                if (musicPlaying) {
                    playMidi();
                }
            }, duration * 1000);
        }

        function stopMusic() {
            scheduledNotes.forEach(({ osc, gain }) => {
                try {
                    osc.stop();
                    osc.disconnect();
                    gain.disconnect();
                } catch (e) {}
            });
            scheduledNotes = [];
            
            if (loopTimeout) {
                clearTimeout(loopTimeout);
                loopTimeout = null;
            }
            
            musicPlaying = false;
            updateMusicButton();
        }

        function toggleMusic() {
            if (musicPlaying) {
                stopMusic();
            } else {
                playMidi();
            }
        }

        function updateMusicButton() {
            const btn = document.getElementById('musicBtn');
            if (musicPlaying) {
                btn.textContent = '';
                btn.classList.add('playing');
            } else {
                btn.textContent = '';
                btn.classList.remove('playing');
            }
        }

        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20;
        const COLORS = {
            empty: '#9bbc0f',
            filled: '#0f380f',
            ghost: '#306230'
        };

        // Tetromino shapes
        const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
        };

        const SHAPE_NAMES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];

        // Game state
        let canvas, ctx, nextCanvas, nextCtx;
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameLoop = null;
        let dropCounter = 0;
        let lastTime = 0;
        let gameState = 'start'; // start, playing, paused, gameover

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('nextCanvas');
            nextCtx = nextCanvas.getContext('2d');

            setupControls();
            resetBoard();
            draw();
        }

        function resetBoard() {
            board = [];
            for (let row = 0; row < ROWS; row++) {
                board[row] = [];
                for (let col = 0; col < COLS; col++) {
                    board[row][col] = 0;
                }
            }
        }

        function createPiece(type) {
            const shape = SHAPES[type];
            return {
                type: type,
                shape: shape,
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
        }

        function randomPiece() {
            const type = SHAPE_NAMES[Math.floor(Math.random() * SHAPE_NAMES.length)];
            return createPiece(type);
        }

        function rotate(piece, dir) {
            const shape = piece.shape;
            const rows = shape.length;
            const cols = shape[0].length;
            const rotated = [];

            for (let col = 0; col < cols; col++) {
                rotated[col] = [];
                for (let row = 0; row < rows; row++) {
                    if (dir > 0) {
                        rotated[col][rows - 1 - row] = shape[row][col];
                    } else {
                        rotated[col][row] = shape[rows - 1 - row][col];
                    }
                }
            }

            return rotated;
        }

        function collides(piece, offsetX = 0, offsetY = 0, shape = null) {
            const s = shape || piece.shape;
            for (let row = 0; row < s.length; row++) {
                for (let col = 0; col < s[row].length; col++) {
                    if (s[row][col]) {
                        const newX = piece.x + col + offsetX;
                        const newY = piece.y + row + offsetY;

                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }

                        if (newY >= 0 && board[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge(piece) {
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const y = piece.y + row;
                        const x = piece.x + col;
                        if (y >= 0) {
                            board[y][x] = 1;
                        }
                    }
                }
            }
        }

        function clearLines() {
            let linesCleared = 0;

            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row].every(cell => cell)) {
                    board.splice(row, 1);
                    board.unshift(new Array(COLS).fill(0));
                    linesCleared++;
                    row++;
                }
            }

            if (linesCleared > 0) {
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared] * level;
                lines += linesCleared;
                level = Math.floor(lines / 10) + 1;
                updateDisplay();
            }
        }

        function drop() {
            if (!collides(currentPiece, 0, 1)) {
                currentPiece.y++;
            } else {
                merge(currentPiece);
                clearLines();
                currentPiece = nextPiece;
                nextPiece = randomPiece();
                drawNext();

                if (collides(currentPiece)) {
                    gameOver();
                }
            }
        }

        function hardDrop() {
            while (!collides(currentPiece, 0, 1)) {
                currentPiece.y++;
                score += 2;
            }
            updateDisplay();
            drop(); // Lock piece immediately
            dropCounter = 0;
        }

        function moveLeft() {
            if (!collides(currentPiece, -1, 0)) {
                currentPiece.x--;
            }
        }

        function moveRight() {
            if (!collides(currentPiece, 1, 0)) {
                currentPiece.x++;
            }
        }

        function rotatePiece(dir) {
            const rotated = rotate(currentPiece, dir);
            
            // Wall kick attempts
            const kicks = [0, -1, 1, -2, 2];
            for (const kick of kicks) {
                if (!collides(currentPiece, kick, 0, rotated)) {
                    currentPiece.shape = rotated;
                    currentPiece.x += kick;
                    return;
                }
            }
        }

        function getGhostY() {
            let ghostY = currentPiece.y;
            while (!collides(currentPiece, 0, ghostY - currentPiece.y + 1)) {
                ghostY++;
            }
            return ghostY;
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = COLORS.empty;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#8bac0f';
            ctx.lineWidth = 1;
            for (let row = 0; row <= ROWS; row++) {
                ctx.beginPath();
                ctx.moveTo(0, row * BLOCK_SIZE);
                ctx.lineTo(canvas.width, row * BLOCK_SIZE);
                ctx.stroke();
            }
            for (let col = 0; col <= COLS; col++) {
                ctx.beginPath();
                ctx.moveTo(col * BLOCK_SIZE, 0);
                ctx.lineTo(col * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }

            // Draw board
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        drawBlock(ctx, col, row, COLORS.filled);
                    }
                }
            }

            // Draw ghost piece
            if (currentPiece && gameState === 'playing') {
                const ghostY = getGhostY();
                for (let row = 0; row < currentPiece.shape.length; row++) {
                    for (let col = 0; col < currentPiece.shape[row].length; col++) {
                        if (currentPiece.shape[row][col]) {
                            drawBlock(ctx, currentPiece.x + col, ghostY + row, COLORS.ghost, true);
                        }
                    }
                }
            }

            // Draw current piece
            if (currentPiece && gameState === 'playing') {
                for (let row = 0; row < currentPiece.shape.length; row++) {
                    for (let col = 0; col < currentPiece.shape[row].length; col++) {
                        if (currentPiece.shape[row][col]) {
                            drawBlock(ctx, currentPiece.x + col, currentPiece.y + row, COLORS.filled);
                        }
                    }
                }
            }
        }

        function drawBlock(context, x, y, color, isGhost = false) {
            const padding = 1;
            context.fillStyle = color;
            
            if (isGhost) {
                context.strokeStyle = color;
                context.lineWidth = 2;
                context.strokeRect(
                    x * BLOCK_SIZE + padding,
                    y * BLOCK_SIZE + padding,
                    BLOCK_SIZE - padding * 2,
                    BLOCK_SIZE - padding * 2
                );
            } else {
                context.fillRect(
                    x * BLOCK_SIZE + padding,
                    y * BLOCK_SIZE + padding,
                    BLOCK_SIZE - padding * 2,
                    BLOCK_SIZE - padding * 2
                );

                // Retro highlight effect
                context.fillStyle = '#306230';
                context.fillRect(
                    x * BLOCK_SIZE + padding + 2,
                    y * BLOCK_SIZE + padding + 2,
                    BLOCK_SIZE - padding * 2 - 6,
                    BLOCK_SIZE - padding * 2 - 6
                );
                
                context.fillStyle = color;
                context.fillRect(
                    x * BLOCK_SIZE + padding + 4,
                    y * BLOCK_SIZE + padding + 4,
                    BLOCK_SIZE - padding * 2 - 10,
                    BLOCK_SIZE - padding * 2 - 10
                );
            }
        }

        function drawNext() {
            nextCtx.fillStyle = COLORS.empty;
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            if (nextPiece) {
                const offsetX = (4 - nextPiece.shape[0].length) / 2;
                const offsetY = (4 - nextPiece.shape.length) / 2;

                for (let row = 0; row < nextPiece.shape.length; row++) {
                    for (let col = 0; col < nextPiece.shape[row].length; col++) {
                        if (nextPiece.shape[row][col]) {
                            drawBlock(nextCtx, offsetX + col, offsetY + row, COLORS.filled);
                        }
                    }
                }
            }
        }

        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
        }

        function getDropInterval() {
            return Math.max(50, 1000 - (level - 1) * 100);
        }

        function update(time = 0) {
            if (gameState !== 'playing') return;

            // Handle first frame - initialize lastTime
            if (lastTime === 0) {
                lastTime = time;
            }

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > getDropInterval()) {
                drop();
                dropCounter = 0;
            }

            draw();
            gameLoop = requestAnimationFrame(update);
        }

        function startGame() {
            resetBoard();
            score = 0;
            level = 1;
            lines = 0;
            updateDisplay();
            
            currentPiece = randomPiece();
            nextPiece = randomPiece();
            drawNext();
            
            gameState = 'playing';
            hideOverlays();
            lastTime = 0;
            dropCounter = 0;
            update();
        }

        function pauseGame() {
            gameState = 'paused';
            cancelAnimationFrame(gameLoop);
            document.getElementById('pauseOverlay').classList.remove('hidden');
        }

        function hidePauseOverlay() {
            document.getElementById('pauseOverlay').classList.add('hidden');
        }

        function resumeGame() {
            gameState = 'playing';
            lastTime = 0;
            hidePauseOverlay();
            gameLoop = requestAnimationFrame(update);
        }

        function gameOver() {
            gameState = 'gameover';
            cancelAnimationFrame(gameLoop);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverOverlay').classList.remove('hidden');
        }

        function hideOverlays() {
            document.getElementById('startOverlay').classList.add('hidden');
            document.getElementById('gameOverOverlay').classList.add('hidden');
        }

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (gameState === 'playing') {
                    switch (e.key) {
                        case 'ArrowLeft':
                            moveLeft();
                            break;
                        case 'ArrowRight':
                            moveRight();
                            break;
                        case 'ArrowDown':
                            drop();
                            score += 1;
                            updateDisplay();
                            break;
                        case 'ArrowUp':
                            hardDrop();
                            break;
                        case 'z':
                        case 'Z':
                            rotatePiece(-1);
                            break;
                        case 'x':
                        case 'X':
                            rotatePiece(1);
                            break;
                        case ' ':
                            hardDrop();
                            break;
                    }
                    draw();
                }

                if (e.key === 'Enter') {
                    if (gameState === 'start' || gameState === 'gameover') {
                        startGame();
                    } else if (gameState === 'playing') {
                        pauseGame();
                    } else if (gameState === 'paused') {
                        resumeGame();
                    }
                }

                if (e.key === 'm' || e.key === 'M') {
                    toggleMusic();
                }
            });

            // Button controls
            document.getElementById('leftBtn').addEventListener('click', () => {
                if (gameState === 'playing') { moveLeft(); draw(); }
            });

            document.getElementById('rightBtn').addEventListener('click', () => {
                if (gameState === 'playing') { moveRight(); draw(); }
            });

            document.getElementById('downBtn').addEventListener('click', () => {
                if (gameState === 'playing') { drop(); score += 1; updateDisplay(); draw(); }
            });

            document.getElementById('upBtn').addEventListener('click', () => {
                if (gameState === 'playing') { hardDrop(); draw(); }
            });

            document.getElementById('aBtn').addEventListener('click', () => {
                if (gameState === 'playing') { rotatePiece(1); draw(); }
            });

            document.getElementById('bBtn').addEventListener('click', () => {
                if (gameState === 'playing') { rotatePiece(-1); draw(); }
            });

            document.getElementById('startBtn').addEventListener('click', () => {
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused') {
                    resumeGame();
                }
            });

            document.getElementById('musicBtn').addEventListener('click', () => {
                toggleMusic();
            });

            // Touch support for mobile
            let touchStartX, touchStartY;
            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            canvas.addEventListener('touchend', (e) => {
                if (gameState !== 'playing') return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;

                if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                    rotatePiece(1);
                } else if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30) moveRight();
                    else if (dx < -30) moveLeft();
                } else {
                    if (dy > 30) hardDrop();
                }
                draw();
            });
        }

        // Start the game
        init();
    </script>
</body>
</html>
